#include <iostream>
#include <setjmp.h>

class BVH
{
public:
	int MAX_OBJECTS_PER_LEAF = 1;

	enum class TYPE : uint8_t { NODE, LEAF };

	struct Node {
		uint32_t numObjects;
		int* objects;
		Node* left;
		Node* right;
		TYPE type;
		int BV;
	};

public:
	BVH() : root(nullptr) {}
	~BVH() = default;


	//Top down are most common, easiest to make, but aren't the best trees
	void StartTopDownBVTree(int objects[], int numobjects)
	{
		TopDownBVTree(&root, objects, numobjects);
	}
	//You start with all objects and recursively split them into groups of 2 and calculate bounding volumes
	//bounding volume takes in a bunch of objects and just finds a good bounding volume which contains all of their bounding volumes
	//partition just splits objects in 2, probably by a plane and sort them in terms of distance to plane 
	void TopDownBVTree(Node** node, int objects[], int numobjects)
	{
		if (numobjects == 0)
		{
			std::cout << "numobjects is 0 in topdown call error\n";
			return;
		}

		Node* newnode = new Node;
		*node = newnode;

		newnode->BV = 0; //CalculateBoundingVolume(objects,numobjects)
		//depending on bounding volume type of objects you would just create one that contains them all. Spheres you create largest sphere of spheres. Box you would just get min max of every box, etc.

		if (numobjects <= MAX_OBJECTS_PER_LEAF)
		{
			newnode->type = TYPE::LEAF;
			newnode->objects = objects;
			newnode->numObjects = numobjects;
		}
		else
		{
			newnode->type = TYPE::NODE;

			int k = 1;// partition(objects, numobjects);
			//for partition you pick an axis. This could be x,y,z. The obb axis. Axis with greatest variance.
			//Once you have an axis pick a point. usually the median or mean of centroids. Or the median of the parent bounding volume.

			TopDownBVTree(&newnode->left, &objects[0], k);
			TopDownBVTree(&newnode->right, &objects[k], numobjects - k);
		}
	}

	void StartBottomUpBVTree(int object[], int numObjects)
	{
		root = BottomUpBVTree(object, numObjects);
	}
	//we start with all objects in bounding volumes then have to merge them together and go up the tree. This is harder to do but produces better trees.
	//grab 2 to merge, create a parent node to hold them with new bounding volume. clear two processed nodes from list and add this new one.
	Node* BottomUpBVTree(int object[], int numObjects)
	{
		if (numObjects == 0)
		{
			std::cout << "numobjects is 0 in botdown call error\n";
		}

		int i, j;

		//create a list of node*. This represent all the objects as leafs at bottom of tree
		Node** nodelist = new Node*[numObjects];
		for (int i = 0; i < numObjects; i++)
		{
			nodelist[i] = new Node;
			nodelist[i]->type = TYPE::LEAF;
			nodelist[i]->objects = &object[i];
		}

		while (numObjects > 1)
		{
			//get 2 children nodes to merge
			//FindNodesToMerge(&nodelist[0], numObjects, &i, &j);
			//You can do brute force O(n^3), which is just loop through every pair and compute bounding volume and pick ones with minimum bounding volume
			//Another method uses a priority queue, to find minimum volume quicker
			//Another method is to actually find nearest neighbor using k-d tree. 
			//However since my number of objects is low probably best to stick with brute force approach

			//create new parent node that holds the 2 children nodes we are merging
			Node* pair = new Node;
			pair->type = TYPE::NODE;
			pair->left = nodelist[i];
			pair->right = nodelist[j];
			pair->BV = 0;//compute boundingvolume on nodelist[i]->object and nodelist[j]->object

			//now remove the 2 children we proccessed from nodelist and add the new one to the list
			int min = i;
			int max = j;
			if (i > j) min = j, max = i;

			nodelist[min] = pair;
			nodelist[max] = nodelist[numObjects - 1];
			numObjects--;
		}
		//free the nodelist we made. We don't need the array that holds the node pointers. We still need all the leafs and nodes we created with new though.
		Node* root = nodelist[0];
		delete nodelist;
		return root;
	}

	//optimizing - store trees in arrays, store trees in cache-friendly trees, get rid of recursion, if theres specific arrange tree so things come first that will be needed so it can leave early
	//caching - store data from previous frstrum cull which could be used

public:
	
	Node* root;
};

class OctTree {
public:

	struct Node {
		float center;
		float halfWidth;
		Node* pchildren[8];
		int*  objlist;
	};

	//stored as array. Children be node[8*i+1] through node[8*i+8]
	//oct tree has (8^n-1)/(8-1) nodes for n depth. 
	//Array is good for static oct-tree. Pointer based is better for dynamic scene.
	//for dynamic objects you want to not split up geometry and just place it in the first box its completely contained in
	//for static just do a AABB child volume overlap test to see if it belongs into one of the 8 volumes

	//preallocated an octree with an initial aabb and a stop depth (5 or 6 usually)
	Node* BuildOctree(int center, float halfwidth, int stopDepth)
	{
		if (stopDepth < 0) return nullptr;
		else
		{
			//construct main node for this call here
			Node* rootnode = new Node;
			rootnode->center = center;
			rootnode->halfWidth = halfwidth;
			rootnode->objlist = nullptr;

			//construct main nodes 8 children
			int centerx, centery, centerz;
			float new_width = halfwidth * .5;
			for (int i = 0; i < 8; i++)
			{
			  centerx = (i & 1) ? new_width : -new_width;
			  centery = (i & 2) ? new_width : -new_width;
			  centerz = (i & 4) ? new_width : -new_width;

			  rootnode->pchildren[i] = BuildOctree(centerx, new_width, stopDepth - 1);
			}

			return rootnode;
		}
	}

	//This is good for dynamic, for static I could insert object into multiple nodes. All I do is not care if its straddling and just figure out which of 8 volumes its touching and insert them.
	//Could just do AABB to sphere intersection or some extra logic with plane splitting
	void InsertOcttree(Node* node, int object)
	{
		//we know the root contains every object, and if we call another insert we only do it if the object is in that child volume so we can assume were inside, or partially the aabb of this node

		//check to see if bounding sphere is on both sides of x, or y, or z plane
		int index = 0;
		int straddle = 0;
		for (int i = 0; i < 3; i++)
		{
			//float delta = object.center.x - node->center.x;
			//if (abs(delta) < object->radius)
			////{
				straddle = 1;
		//		break;
			//}
		//	if (delta > 0.0f) index |= (1 << i);  //0-7  i == 0 (0000, 0001) i==2 (0010, 0011) i==3 (0100, 0101, 0111)
		}

		if (!straddle && node->pchildren[index])
		{
			//fully contained in a child insert into this one
			InsertOcttree(node->pchildren[index], object);
		}
		else
		{
			//its straddling or child node doesn't exist so we stop and insert object here
			node->objlist = &object;
		}

		//if its preallocated already than were done, else if your at a leaf and your not at some constraint you'd create 8 new children and put everything in that
	}

};

//https://pbr-book.org/3ed-2018/Primitives_and_Intersection_Acceleration/Kd-Tree_Accelerator#KdTreeAccel::buildTree
class KDTree
{
public:
	struct Node {
		Node* child[2];//above plane below plane
		int splittype; //x,y,z axis split
		float splitValue; //position of split plane
		int* objects;
	};

	//this is very similar to bvh construction do a top-down even bottom-up recursion. You pick the splitting plane and each object goes in one or two of the bins. repeat until criteria is filled.

	//thats how to construct then given a sphere this function calculates all nodes its contained in
	void VisitOverlappedNodes(Node* node, int sphere, int &nearpoint)
	{
		if (node == nullptr) return;

		//compare what side of the plane spheres center is on
		/*int first = sphere->center.x > node->splitValue;
		
		//visit that node now
		VisitOverlappedNodes(node->child[first], sphere, nearpoint);

		//
		float oldvalue = nearpoint.x;
		nearpoint.x = node->splitValue;

		if (sqrtdistance(nearpoint, sphere->center) < sphere->radius*sphere->radius)
		{
			VisitOverlappedNodes(node->child[first ^ 1], sphere, nearpoint);
		}

		nearpoint.x = oldvalue;
		*/
	}

};

//data structures if its static you can actually just make multiple copies of data and store if on different data structures because its static so you can remove pointer dereferencing
//if its dynamic making copies won't really work
//I think I have to make the bucket system hold the actual data so looping is dummy fast. Then other data structures like spatial hold pointers, we know the linear search will access every
//element so we don't want to dereference every element, a spatial structure on the other hand won't dereference every element.
//So you have an object pool which is dynamically allocated but contiguously. Might have to not use pool just preallocate the lists
//so I have preallocated list of opaque, and dynamic objects,  static, transparent, etc. Then every other data structure points to that memory. We just have to make sure we don't change memory in
//the lists of course, we have to keep the data structures constant or else it will just delete and copy over memory deleting the reference pointers

// * So I have 4 contiguous arrays which store static/dynamic/opaque/transparent combinations. Each array is preallocated because we can't delete the memory or else references will be junk.
//Then you have some counter which keeps track of open slots and when you add or remove elements you just make the slot open kind of like a pool. Its pretty much a pool.
//This way we have super quick contiguous access when we want to loop through every element.
//If we want other data structures like spatial well its going to have to store pointer (which is better because we won't need to dereference every object anymore making it more bearable).
//So its going to need a pointer into the main array, the problem of course is if we change the slot its in which really is only a problem of sorting which we only do for transparency.
//So I can have another data structure which is an array and at index renderobjectid it stores its current spot in the data structure. When you change sorting you change that structure. Then the tree,
//has that new slot number it will point to

//for example for shadows it only has to calculate shadows for static objects once then just draw dynamic objects and blend that over. Only if the light moves does it have to reload that.
//for data structures we can precompute everything for static objects

//1.) all pointers
//2.) just a bunch of contiguous arrays
//3.) hybrid

//BVH, KDTREE, OCTREE
//AABB, SPHERE, OBB, K-DOP


//FRUSTRUM-INTERSECTION
//we have to know if bounding volume is completely outside, completely inside, or partially inside the frustrum
//spheres has harder algorithm
//box you can project 8 points with pv matrix and divide by w. Theres also a quicker way to do it on cpu just doing box/plane intersection

//Oct-tree AABB with AABB/Sphere/OBB/etc


int main()
{


	return 0;
}
