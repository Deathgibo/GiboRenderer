#version 450
#extension GL_ARB_separate_shader_objects : enable

#define LOCAL_WORKGROUP_SIZE 32

layout(local_size_x=LOCAL_WORKGROUP_SIZE, local_size_y=LOCAL_WORKGROUP_SIZE, local_size_z=1) in;

layout(set = 0, binding=0) uniform sampler2D depth_prepass;
layout(set = 0, binding = 3) uniform sampler2DMS  depth_prepassMS;

const int x_size = 5;
const int y_size = 5;
const int z_size = 5;

layout(set = 0, binding = 2) uniform FrustrumBuffer
{
  mat4 proj;
  
  float near;
  float far;
  float a; //0 means single sampling, 1 means multisampling
  float b;
} pv;

layout(set = 0, binding = 4) writeonly buffer ActiveClusters
{
	bool active_list[];
} active_clusters;

//the depth should be a number between near_plane - far_plane
int DepthSlice(float depth)
{
	return int(floor(log(depth)*(z_size/log(pv.far/pv.near)) - ((z_size*log(pv.near)) / log(pv.far/pv.near))));
}

int GetClusterIndex(float depth, vec2 uv)
{
	//depth is in nonlinear clip space between 0 and 1
	//convert depth to linear depth.
	depth = pv.proj[3][2] / (-depth - pv.proj[2][2]);
	depth = clamp((-depth - pv.near) / (pv.far - pv.near), 0.0, 1.0);
	
	//convert to actual camera space z value. Use negative z values
	depth = -pv.near + (-pv.far+pv.near)*depth;

	int x_bucket = int(floor(uv.x * x_size));
	int y_bucket = int(floor(uv.y * y_size));
	int z_bucket = DepthSlice(depth);

	int cluster_index = z_bucket*x_size*y_size + x_bucket*y_size + y_bucket;

	return cluster_index;
}

//loop through every pixel of depth-prepass. Get its z value and calculate which cluster it is in based on how we generated them. Not AABB because we want a unique one.
//Each AABB contains the cluster and if it intersects multiple AABB its okay to just set that 1 cluster and rest to false.
//all clusters start as false, if we have a pixel in it though we set it to tru
void main()
{

   ivec2 texture_dimensions;
   texture_dimensions = textureSize(depth_prepass, 0);

    ivec2 sample_pos = ivec2(gl_GlobalInvocationID.xy);
	sample_pos = min(sample_pos, texture_dimensions - 1); //shaders that are "out of bounds" can just get clamped and repeat same algorithm

	vec2 uv = vec2(sample_pos.xy) / vec2(texture_dimensions.x - 1, texture_dimensions.y - 1);

	float depth = texture(depth_prepass, uv).r;

	//map depth value to a cluster 
	int cluster_index = GetClusterIndex(depth, uv);


	active_clusters.active_list[cluster_index] = true;
}